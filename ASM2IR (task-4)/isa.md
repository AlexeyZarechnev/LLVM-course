# Мой личный набор инструкций:

## Арифметика

**Сигнатура** `func arg0 arg1 arg2` - `arg0` регистр для записи результата, `arg1` `arg2` аргументы константы или регистры со значениями
1. `add` - сложение 
2. `sub` - вычитание
3. `mul` - умножение

## Работа с указателями

* `alloca arg0 arg1` - выделяет на стеке массив int'ов размера `arg1` и записывает указаетель в регистр `arg0`
* `gep2 size arg0 arg1 arg2 arg3 arg4 arg5 arg6` - получает указатель на нужный элемент: `size` - размер массива, `arg0` регистр для записи результата, `arg1` константа (размер 2 измерения массива), `arg2` указатель на массив, `arg3` `arg4` индексы, `arg5` `arg6` оффсеты для индексов
* `load arg0 arg1` - загружает int по указателю: `arg0` регистр для записи результата, `arg1` указатель на элемент
* `store arg0 arg1` - сохраняет int по указателю: `arg0` указатель для записи результата, `arg1` значение

## Булевы функции

* `eq arg0 arg1 arg2` - проверяет значения на равенство: `arg0` регистр для записи результата, `arg1` `arg2` аргументы константы или регистры со значениями
* `neq arg0 arg1 arg2` - проверяет значения на равенство: `arg0` регистр для записи результата, `arg1` `arg2` аргументы константы или регистры со значениями

## Контроль порядка исполнения

* `br label` - перемещает исполнение на label
* `br_cond arg0 label` - перемещает исполнение на label если `arg0` true
* `EXIT` - завершает программу

## Графика

* `FILL_INIT_STATE arg0` - `arg0` аргумент fill_init_state
* `PUT_PIXEL arg0 arg1 arg2` - `arg0` `arg1` `arg2` аргументы put_pixel
* `FLUSH arg0` - `arg0` сохраняет результат